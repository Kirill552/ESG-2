/**
 * –ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–∞—è OCR —Å–∏—Å—Ç–µ–º–∞ –¥–ª—è EGS-Lite
 * –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: Yandex Vision ‚Üí Tesseract Fallback ‚Üí –±—É–¥—É—â–∏–π Donut —Å–ª–æ—Ç
 */

import { processImage, processImageDetailed } from './ocr';

interface OcrResult {
  text: string;
  confidence: number;
  source: 'yandex' | 'tesseract' | 'donut';
  processingTime: number;
  words?: Array<{
    text: string;
    confidence: number;
    bbox?: { x: number; y: number; width: number; height: number };
  }>;
}

interface OcrError {
  service: string;
  error: string;
  code?: string;
}

/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å Yandex Vision API
 */
async function isYandexVisionAvailable(): Promise<boolean> {
  try {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
    const hasServiceAccount = process.env.YANDEX_SERVICE_ACCOUNT_KEY_FILE || process.env.YANDEX_IAM_TOKEN;
    const hasFolderId = process.env.YANDEX_FOLDER_ID;
    
    if (!hasServiceAccount || !hasFolderId) {
      console.log('üîç Yandex Vision: missing credentials, using fallback');
      return false;
    }

    // –ü—ã—Ç–∞–µ–º—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å –º–æ–¥—É–ª—å Yandex Vision
    const { processImageWithYandex } = await import('./yandex-vision-service');
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    if (typeof processImageWithYandex === 'function') {
      console.log('‚úÖ Yandex Vision available as primary OCR');
      return true;
    }
    
    return false;
  } catch (error) {
    console.log('üîç Yandex Vision module not available, using fallback');
    return false;
  }
}

/**
 * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —á–µ—Ä–µ–∑ Yandex Vision OCR
 */
async function processWithYandex(buffer: Buffer): Promise<OcrResult> {
  const startTime = Date.now();
  
  try {
    const { processImageWithYandex } = await import('./yandex-vision-service');
    const result = await processImageWithYandex(buffer);
    
    const processingTime = Date.now() - startTime;
    
    return {
      text: result.text || '',
      confidence: result.confidence || 0.9,
      source: 'yandex',
      processingTime,
      words: result.words
    };
  } catch (error: any) {
    throw new Error(`YANDEX_OCR_FAILED: ${error.message}`);
  }
}

/**
 * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —á–µ—Ä–µ–∑ Tesseract OCR (fallback)
 */
async function processWithTesseract(buffer: Buffer): Promise<OcrResult> {
  const startTime = Date.now();
  
  try {
    const result = await processImageDetailed(buffer);
    const processingTime = Date.now() - startTime;
    
    return {
      text: result.text || '',
      confidence: result.confidence || 0.5,
      source: 'tesseract',
      processingTime,
      words: result.words
    };
  } catch (error: any) {
    throw new Error(`TESSERACT_OCR_FAILED: ${error.message}`);
  }
}

/**
 * –°–ª–æ—Ç –¥–ª—è –±—É–¥—É—â–µ–π –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ –æ–±—É—á–µ–Ω–Ω–æ–≥–æ Donut
 */
async function processWithDonut(buffer: Buffer): Promise<OcrResult> {
  const startTime = Date.now();
  
  try {
    // TODO: –ü–æ—Å–ª–µ –¥–æ–æ–±—É—á–µ–Ω–∏—è Donut –º–æ–¥–µ–ª–∏ –Ω–∞ 19,919 —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏—Ö –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ö
    // –∑–∞–º–µ–Ω–∏—Ç–µ —ç—Ç–æ—Ç –±–ª–æ–∫ –Ω–∞ —Ä–µ–∞–ª—å–Ω—É—é –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—é:
    
    /*
    –ü–õ–ê–ù–ò–†–£–ï–ú–ê–Ø –ò–ù–¢–ï–ì–†–ê–¶–ò–Ø DONUT:
    
    1. –ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏:
       const donutModel = await loadDonutModel('./models/donut-esg-finetuned');
    
    2. –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:
       const imageBase64 = buffer.toString('base64');
       const preprocessed = await preprocessImageForDonut(imageBase64);
    
    3. –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö:
       const result = await donutModel.predict(preprocessed, {
         task: 'carbon_data_extraction',
         language: 'ru',
         confidence_threshold: 0.85
       });
    
    4. –ü–æ—Å—Ç–æ–±—Ä–∞–±–æ—Ç–∫–∞:
       return {
         text: result.extracted_text,
         confidence: result.confidence,
         source: 'donut',
         processingTime: Date.now() - startTime,
         words: result.structured_words,
         structured_data: result.carbon_data // –£–Ω–∏–∫–∞–ª—å–Ω–∞—è —Ñ–∏—á–∞ Donut
       };
    
    –û–ñ–ò–î–ê–ï–ú–ê–Ø –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–¨:
    - –¢–æ—á–Ω–æ—Å—Ç—å: 92-95% –Ω–∞ —Ä–æ—Å—Å–∏–π—Å–∫–∏—Ö –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ö
    - –°–∫–æ—Ä–æ—Å—Ç—å: 2-5 —Å–µ–∫ –Ω–∞ –¥–æ–∫—É–º–µ–Ω—Ç (CPU: 5-8 —Å–µ–∫, GPU: 1-2 —Å–µ–∫)
    - –°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –µ–¥–∏–Ω–∏—Ü –∏–∑–º–µ—Ä–µ–Ω–∏—è
    - –ü–æ–Ω–∏–º–∞–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞: —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —É–≥–ª–µ—Ä–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    */
    
    // –í—Ä–µ–º–µ–Ω–Ω–∞—è –∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã
    console.log('üç© Donut OCR slot called but not implemented yet');
    console.log('üìä Training in progress on 19,919 synthetic documents...');
    console.log('üéØ Expected completion: 3-6 hours on A100 GPU');
    console.log('üí∞ Estimated cost: $10-15 for training');
    
    throw new Error('DONUT_TRAINING_IN_PROGRESS: Model is being trained on synthetic dataset. Expected accuracy: 92-95%');
    
  } catch (error: any) {
    throw new Error(`DONUT_OCR_FAILED: ${error.message}`);
  }
}

/**
 * –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –º–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–æ–π OCR –æ–±—Ä–∞–±–æ—Ç–∫–∏
 */
export async function processImageMultiLevel(
  buffer: Buffer, 
  options: {
    preferredSource?: 'auto' | 'yandex' | 'tesseract' | 'donut';
    enableFallback?: boolean;
    minConfidence?: number;
  } = {}
): Promise<OcrResult> {
  const { 
    preferredSource = 'auto', 
    enableFallback = true, 
    minConfidence = 0.6 
  } = options;

  const errors: OcrError[] = [];
  let lastResult: OcrResult | null = null;

  console.log(`üîç Starting multi-level OCR processing (${buffer.length} bytes)`);
  console.log(`üìã Preferred: ${preferredSource}, Fallback: ${enableFallback}, Min confidence: ${minConfidence}`);

  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ—Ä—è–¥–æ–∫ –æ–±—Ä–∞–±–æ—Ç–∫–∏
  const processingOrder: Array<'yandex' | 'tesseract' | 'donut'> = [];
  
  if (preferredSource === 'auto') {
    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –≤—ã–±–æ—Ä: –ø—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å Yandex, –ø–æ—Ç–æ–º Tesseract
    const yandexAvailable = await isYandexVisionAvailable();
    if (yandexAvailable) {
      processingOrder.push('yandex', 'tesseract');
    } else {
      processingOrder.push('tesseract');
    }
  } else if (preferredSource === 'yandex') {
    processingOrder.push('yandex');
    if (enableFallback) processingOrder.push('tesseract');
  } else if (preferredSource === 'tesseract') {
    processingOrder.push('tesseract');
  } else if (preferredSource === 'donut') {
    processingOrder.push('donut');
    if (enableFallback) processingOrder.push('yandex', 'tesseract');
  }

  // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É
  for (const source of processingOrder) {
    try {
      console.log(`üîÑ Trying ${source.toUpperCase()} OCR...`);
      
      let result: OcrResult;
      
      switch (source) {
        case 'yandex':
          result = await processWithYandex(buffer);
          break;
        case 'tesseract':
          result = await processWithTesseract(buffer);
          break;
        case 'donut':
          result = await processWithDonut(buffer);
          break;
        default:
          throw new Error(`Unknown OCR source: ${source}`);
      }

      lastResult = result;
      
      console.log(`‚úÖ ${source.toUpperCase()} OCR completed: ${result.text.length} chars, confidence: ${result.confidence.toFixed(2)}, time: ${result.processingTime}ms`);
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞—á–µ—Å—Ç–≤–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
      if (result.confidence >= minConfidence && result.text.length > 10) {
        console.log(`üéØ OCR result accepted from ${source.toUpperCase()}`);
        return result;
      } else {
        console.log(`‚ö†Ô∏è ${source.toUpperCase()} result below threshold (confidence: ${result.confidence.toFixed(2)}, length: ${result.text.length}), trying next...`);
        
        if (!enableFallback) {
          return result; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–∞–∂–µ –µ—Å–ª–∏ –∫–∞—á–µ—Å—Ç–≤–æ –Ω–∏–∑–∫–æ–µ, –µ—Å–ª–∏ fallback –æ—Ç–∫–ª—é—á–µ–Ω
        }
      }
      
    } catch (error: any) {
      console.log(`‚ùå ${source.toUpperCase()} OCR failed:`, error.message);
      
      errors.push({
        service: source,
        error: error.message,
        code: error.code
      });
      
      if (!enableFallback) {
        throw error; // –ï—Å–ª–∏ fallback –æ—Ç–∫–ª—é—á–µ–Ω, –±—Ä–æ—Å–∞–µ–º –æ—à–∏–±–∫—É —Å—Ä–∞–∑—É
      }
    }
  }

  // –ï—Å–ª–∏ –¥–æ—à–ª–∏ –¥–æ —Å—é–¥–∞, –≤—Å–µ –º–µ—Ç–æ–¥—ã –ª–∏–±–æ –Ω–µ—É—Å–ø–µ—à–Ω—ã, –ª–∏–±–æ –¥–∞–ª–∏ –Ω–∏–∑–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ
  if (lastResult) {
    console.log(`‚ö†Ô∏è Returning last result with low confidence from ${lastResult.source.toUpperCase()}`);
    return lastResult;
  }

  // –í—Å–µ –º–µ—Ç–æ–¥—ã –ø—Ä–æ–≤–∞–ª–∏–ª–∏—Å—å
  const errorSummary = errors.map(e => `${e.service}: ${e.error}`).join('; ');
  throw new Error(`ALL_OCR_METHODS_FAILED: ${errorSummary}`);
}

/**
 * –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –±—ã—Å—Ç—Ä–æ–π OCR –æ–±—Ä–∞–±–æ—Ç–∫–∏ (—Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç)
 */
export async function processImageQuick(buffer: Buffer): Promise<string> {
  try {
    const result = await processImageMultiLevel(buffer, {
      preferredSource: 'auto',
      enableFallback: true,
      minConfidence: 0.3 // –°–Ω–∏–∂–∞–µ–º —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è –¥–ª—è –±—ã—Å—Ç—Ä–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
    });
    
    return result.text;
  } catch (error: any) {
    console.error('Quick OCR processing failed:', error.message);
    return ''; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É –≤ —Å–ª—É—á–∞–µ –ø–æ–ª–Ω–æ–π –Ω–µ—É–¥–∞—á–∏
  }
}

/**
 * –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –¥–æ—Å—Ç—É–ø–Ω—ã—Ö OCR –º–µ—Ç–æ–¥–æ–≤
 */
export async function getOcrStatus(): Promise<{
  yandex: { available: boolean; reason?: string };
  tesseract: { available: boolean; reason?: string };
  donut: { available: boolean; reason?: string };
}> {
  const status = {
    yandex: { available: false, reason: '' },
    tesseract: { available: true, reason: 'Always available' },
    donut: { available: false, reason: 'Training in progress on 19,919 synthetic documents (3-6h on A100, $10-15 cost, 92-95% expected accuracy)' }
  };

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º Yandex Vision
  try {
    status.yandex.available = await isYandexVisionAvailable();
    if (!status.yandex.available) {
      status.yandex.reason = 'Missing credentials or module unavailable';
    } else {
      status.yandex.reason = 'Ready to use';
    }
  } catch (error: any) {
    status.yandex.reason = error.message;
  }

  return status;
}

/**
 * –ü–æ—Å—Ç–æ–±—Ä–∞–±–æ—Ç–∫–∞ OCR —Ç–µ–∫—Å—Ç–∞ —á–µ—Ä–µ–∑ Foundation Models (Levels 3-5)
 * Level 3: –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ—à–∏–±–æ–∫ OCR (GigaChat Lite)
 * Level 4: –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö (GigaChat Pro)
 * Level 5: –°–ª–æ–∂–Ω—ã–π –∞–Ω–∞–ª–∏–∑ (GigaChat 2 MAX)
 */
export async function postProcessWithFoundationModels(
  ocrText: string,
  options?: {
    fixErrors?: boolean;
    extractData?: boolean;
    classifyCategory?: boolean;
  }
): Promise<{
  fixedText?: string;
  extractedData?: any;
  category?: string;
  categoryConfidence?: number;
}> {
  const result: {
    fixedText?: string;
    extractedData?: any;
    category?: string;
    categoryConfidence?: number;
  } = {};

  try {
    const { FoundationModelsClient } = await import('./foundation-models-client');
    const client = new FoundationModelsClient();

    // Level 3: –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ—à–∏–±–æ–∫ OCR (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
    if (options?.fixErrors !== false) {
      console.log('üîß Level 3: –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ—à–∏–±–æ–∫ OCR —á–µ—Ä–µ–∑ GigaChat Lite...');
      try {
        result.fixedText = await client.fixOcrErrors(ocrText);
      } catch (error) {
        console.error('‚ö†Ô∏è Level 3 failed, using original text:', error);
        result.fixedText = ocrText;
      }
    }

    const textForProcessing = result.fixedText || ocrText;

    // Level 4: –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
    if (options?.extractData !== false) {
      console.log('üìä Level 4: –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —á–µ—Ä–µ–∑ GigaChat Pro...');
      try {
        const extraction = await client.extractEnergyData(textForProcessing);
        result.extractedData = extraction.extractedData;
      } catch (error) {
        console.error('‚ö†Ô∏è Level 4 failed:', error);
      }
    }

    // Level 5: –ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
    if (options?.classifyCategory !== false) {
      console.log('üè∑Ô∏è Level 5: –ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ —á–µ—Ä–µ–∑ GigaChat 2 MAX...');
      try {
        const classification = await client.classifyDocumentCategory(textForProcessing);
        result.category = classification.category;
        result.categoryConfidence = classification.confidence;
      } catch (error) {
        console.error('‚ö†Ô∏è Level 5 failed:', error);
      }
    }

    return result;
  } catch (error) {
    console.error('‚ùå Foundation Models –ø–æ—Å—Ç–æ–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞:', error);
    return { fixedText: ocrText };
  }
}

/**
 * –ü–æ–ª–Ω–∞—è –º–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞: OCR (Levels 1-2) + –ø–æ—Å—Ç–æ–±—Ä–∞–±–æ—Ç–∫–∞ (Levels 3-5)
 */
export async function processImageWithPostProcessing(
  buffer: Buffer,
  options?: {
    ocrOptions?: MultiLevelOcrOptions;
    postProcessOptions?: {
      fixErrors?: boolean;
      extractData?: boolean;
      classifyCategory?: boolean;
    };
  }
): Promise<OcrResult & {
  fixedText?: string;
  extractedData?: any;
  category?: string;
  categoryConfidence?: number;
}> {
  console.log('üöÄ –ó–∞–ø—É—Å–∫ –ø–æ–ª–Ω–æ–π –º–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ (Levels 1-5)...');

  // Levels 1-2: –ë–∞–∑–æ–≤—ã–π OCR
  const ocrResult = await processImageMultiLevel(buffer, options?.ocrOptions);

  // Levels 3-5: –ü–æ—Å—Ç–æ–±—Ä–∞–±–æ—Ç–∫–∞ —á–µ—Ä–µ–∑ Foundation Models
  const postProcessed = await postProcessWithFoundationModels(
    ocrResult.text,
    options?.postProcessOptions
  );

  return {
    ...ocrResult,
    ...postProcessed
  };
}

/**
 * –≠–∫—Å–ø–æ—Ä—Ç –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º –∫–æ–¥–æ–º
 */
export { processImage as processTesseractImage } from './ocr';